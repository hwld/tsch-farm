{"id":847,"title":"string-join","difficulty":"hard","code":"/*\n  847 - String Join\n  -------\n  by Matt Davis (@tl-matt-davis) #上級\n\n  ### 質問\n\n  Create a type-safe string join utility which can be used like so:\n\n  ```ts\n  const hyphenJoiner = join('-')\n  const result = hyphenJoiner('a', 'b', 'c'); // = 'a-b-c'\n  ```\n\n  Or alternatively:\n  ```ts\n  join('#')('a', 'b', 'c') // = 'a#b#c'\n  ```\n\n  When we pass an empty delimiter (i.e '') to join, we should concat the strings as they are, i.e:\n  ```ts\n  join('')('a', 'b', 'c') // = 'abc'\n  ```\n\n  When only one item is passed, we should get back the original item (without any delimiter added):\n  ```ts\n  join('-')('a') // = 'a'\n  ```\n\n  > GitHubで確認する：https://tsch.js.org/847/ja\n*/\n\n/* _____________ ここにコードを記入 _____________ */\n\ndeclare function join(delimiter: any): (...parts: any[]) => any\n\n/* _____________ テストケース _____________ */\nimport type { Equal, Expect } from '@type-challenges/utils'\n\n// Edge cases\nconst noCharsOutput = join('-')()\nconst oneCharOutput = join('-')('a')\nconst noDelimiterOutput = join('')('a', 'b', 'c')\n\n// Regular cases\nconst hyphenOutput = join('-')('a', 'b', 'c')\nconst hashOutput = join('#')('a', 'b', 'c')\nconst twoCharOutput = join('-')('a', 'b')\nconst longOutput = join('-')('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h')\n\ntype cases = [\n  Expect<Equal<typeof noCharsOutput, ''>>,\n  Expect<Equal<typeof oneCharOutput, 'a'>>,\n  Expect<Equal<typeof noDelimiterOutput, 'abc'>>,\n  Expect<Equal<typeof twoCharOutput, 'a-b'>>,\n  Expect<Equal<typeof hyphenOutput, 'a-b-c'>>,\n  Expect<Equal<typeof hashOutput, 'a#b#c'>>,\n  Expect<Equal<typeof longOutput, 'a-b-c-d-e-f-g-h'>>,\n]\n\n/* _____________ 次のステップ _____________ */\n/*\n  > 解答を共有する：https://tsch.js.org/847/answer/ja\n  > 解答を見る：https://tsch.js.org/847/solutions\n  > その他の課題：https://tsch.js.org/ja\n*/\n"}