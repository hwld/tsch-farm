{"id":30178,"title":"unique-items","difficulty":"hard","code":"/*\n  30178 - Unique Items\n  -------\n  by Evgeniy (@bgenia) #上級 #tuple #application #cif\n\n  ### 質問\n\n  Some concepts in TypeScript can not be described by types, but can be expressed through type constraints. For example, you can't define a type for positive numbers, but you can check whether a number literal type is positive. One of the patterns for applying such constraints is constrained identity function (CIF). A CIF takes one parameter, infers its type, performs additional checks and returns the parameter unmodified.\n\n  ```ts\n  // Ensures `n` is a positive number\n  function positive<const N extends number>(n: `${N}` extends `-${string}` ? never : N) {\n    return n\n  }\n\n  const a = positive(1) // Ok\n  const b = positive(-1) // Error, -1 is not assignable to never\n  ```\n\n  Write a CIF `uniqueItems` that takes a tuple of literals and ensures that all of them are unique.\n  You are free to use either mutable or readonly tuples.\n\n  Bonus task: Helpful error messages instead of `not assignable to never`.\n  Bonus task: Only repeating tuple elements should be treated as errors, not the entire argument.\n\n  > GitHubで確認する：https://tsch.js.org/30178/ja\n*/\n\n/* _____________ ここにコードを記入 _____________ */\n\nfunction uniqueItems(items: any[]) {\r\n  return items\r\n}\n\n/* _____________ テストケース _____________ */\nimport type { Equal } from '@type-challenges/utils'\r\n\r\ndeclare const readonlyEqual: <A>() => <T>(value: T) => Equal<Readonly<A>, Readonly<T>>\r\ndeclare const expect: (value: true) => void\r\n\r\n// Should work\r\nexpect(readonlyEqual<[1, 2, 3]>()(uniqueItems([1, 2, 3])))\r\nexpect(readonlyEqual<['a', 'b', 'c']>()(uniqueItems(['a', 'b', 'c'])))\r\nexpect(readonlyEqual<[1, 'a', true]>()(uniqueItems([1, 'a', true])))\r\nexpect(readonlyEqual<[undefined, null, 3, false]>()(uniqueItems([undefined, null, 3, false])))\r\n\r\n// Should error\r\n// @ts-expect-error\r\nuniqueItems([1, 2, 2, 3, 4, 4, 5, 6])\r\n// @ts-expect-error\r\nuniqueItems([true, true, false, false, 'b', 'b'])\r\n// @ts-expect-error\r\nuniqueItems([1, 1])\r\n// @ts-expect-error\r\nuniqueItems([undefined, undefined])\r\n// @ts-expect-error\r\nuniqueItems([null, undefined, null])\r\n// @ts-expect-error\r\nuniqueItems(['test', undefined, 'test'])\r\n\r\n// Bonus: Should give detailed errors\r\nuniqueItems([\r\n  1,\r\n  2,\r\n  // @ts-expect-error\r\n  2,\r\n  3,\r\n  4,\r\n  // @ts-expect-error\r\n  4,\r\n  6,\r\n  7,\r\n])\r\n\r\nuniqueItems([\r\n  true,\r\n  // @ts-expect-error\r\n  true,\r\n  false,\r\n  // @ts-expect-error\r\n  false,\r\n  'b',\r\n  // @ts-expect-error\r\n  'b',\r\n])\n\n/* _____________ 次のステップ _____________ */\n/*\n  > 解答を共有する：https://tsch.js.org/30178/answer/ja\n  > 解答を見る：https://tsch.js.org/30178/solutions\n  > その他の課題：https://tsch.js.org/ja\n*/\n"}