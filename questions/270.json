{"id":270,"difficulty":"hard","title":"typed-get","code":"/*\n  270 - Typed Get\n  -------\n  by Anthony Fu (@antfu) #上級 #utils #template-literal\n\n  ### 質問\n\n  [lodash の get 関数](https://lodash.com/docs/4.17.15#get)は JavaScript でネストした値にアクセスする際にとても便利です。しかし、TypeScript でこのような関数を使うと型情報が失われてしまいます。\n  TypeScript4.1 の機能である[Template Literal Types](https://devblogs.microsoft.com/typescript/announcing-typescript-4-1-beta/#template-literal-types)を使うと、`get`の適切な型付けが可能となります。\n  これを実装できるでしょうか?\n\n  例えば、\n\n  ```ts\n  type Data = {\n    foo: {\n      bar: {\n        value: 'foobar';\n        count: 6;\n      };\n      included: true;\n    };\n    hello: 'world';\n  };\n  type A = Get<Data, 'hello'>; // 'world'\n  type B = Get<Data, 'foo.bar.count'>; // 6\n  type C = Get<Data, 'foo.bar'>; // { value: 'foobar', count: 6 }\n  ```\n\n  この課題では、配列へのアクセスは必要ありません。\n\n  > GitHubで確認する：https://tsch.js.org/270/ja\n*/\n\n/* _____________ ここにコードを記入 _____________ */\n\ntype Get<T, K> = string\n\n/* _____________ テストケース _____________ */\nimport type { Equal, Expect } from '@type-challenges/utils'\n\ntype cases = [\n  Expect<Equal<Get<Data, 'hello'>, 'world'>>,\n  Expect<Equal<Get<Data, 'foo.bar.count'>, 6>>,\n  Expect<Equal<Get<Data, 'foo.bar'>, { value: 'foobar', count: 6 }>>,\n  Expect<Equal<Get<Data, 'foo.baz'>, false>>,\n\n  Expect<Equal<Get<Data, 'no.existed'>, never>>,\n]\n\ntype Data = {\n  foo: {\n    bar: {\n      value: 'foobar'\n      count: 6\n    }\n    included: true\n  }\n  'foo.baz': false\n  hello: 'world'\n}\n\n/* _____________ 次のステップ _____________ */\n/*\n  > 解答を共有する：https://tsch.js.org/270/answer/ja\n  > 解答を見る：https://tsch.js.org/270/solutions\n  > その他の課題：https://tsch.js.org/ja\n*/\n"}